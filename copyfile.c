#include "defs.h"
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <signal.h>
/****************************************************************************/
				copyfile()
/*                      Копирование файла/файлов
/****************************************************************************/
{
extern  int     cpanel;         /* текущая панель */
extern  struct  panel   panels[];
extern  int     outpanel;       /*обрабатываемая панель */
extern  struct  win     win3;
extern  struct  win     win15;  /* запрос на подтверждение коп-я группы ф.*/
extern  struct  win     win16;  /* сообщение об ошибке*/
extern  struct  win     win17;  /* сообщение об ошибке доступа к каталогу */
extern  struct  win     win19;  /* сообщение о копировании файла(в)*/
extern  struct  win     win20;  /* сообщение о копировании*/
extern  struct  win     win21;  /* сообщение об ошибке копировании*/
extern  struct  win     win77;  /* запрос на Overwrite */
extern  WINDOW  *save_scr;      /* окно для сохранения экрана */
extern  char    *tmp_str;       /* строка для временных данных */
extern  size_t  tmp_len;        /* место, выделенное для tmp_str*/
	char    str[80];
	char    *name;          /* имя файла */
	pid_t   pid;
	pid_t   pid1;
	pid_t   pid_ready;
	int     wait_stat;      /* статус завершения процесса */
 struct itembuf *item;          /* для обработки выбранного файла*/
 struct itembuf *item_mark;     /* для обработки единственного выбранного файла*/
	int     tested;         /* количество проверенных файлов*/
	int     incl_dir;       /* признак наличия каталогов в списке*/
	int     fd[2];
	int     fd_err[2];      /* для переназначения протокола ошибок*/
	char    **spis;         /* список аргументов для программы копирования*/
	char    **spis_p;       /* список аргументов для программы копирования*/
	int     i;
	int     status;         /* состояние завершения процесса*/
	int     copy=0;         /* признак и тип копирования */
	int     panel;          /* "не текущая" панель */
	int     err=0;          /* признак ошибки копирования */
	int     say_error=1;    /* сообщать об ошибках */
	int     nfile;          /* номер текущего файла*/
	int     nfirst;         /* номер первого выводимого файла*/
	int     exists=0;       /* признак необх-сти запроса Overwrite */
	char    *ptr;           /* для образования имени в каталоге */
 struct stat    stbuf;
 struct inp_lst inp_lst[2];       /* список ввода для inp_menu()*/
 static char    *copyprog[]={"", "tar", "ln", "ln", "cp"}; /*программа копирования*/
/*==========================================================================*/
inp_lst[0].str=tmp_str;
/* inp_lst[0].fld_len=...;  выставит inp_menu()*/
inp_lst[0].str_len=tmp_len;
inp_lst[0].npunkt=1;
inp_lst[1].str=NULL; /* признак конца списка для inp_menu()*/

win15.txts[4].active=1;   /* пункт Link мог быть сброшен предыдущим вызовом*/
if(cpanel)
  {
    panel=0;
  }else{
    panel=1;
  }

if(panels[panel].on==1 || panels[panel].on==3 || panels[cpanel].selected)
  { /* противоположная панель включена или есть отмеченные файлы */
    name=panels[panel].full_dir;
  }else{
    name=panels[cpanel].names+panels[cpanel].itembuf[panels[cpanel].curfile].nname;
  }
if(tmp_len<=strlen(name)){
  free(tmp_str);
  tmp_len=(strlen(name)/128+1)*128;
  tmp_str=malloc(tmp_len);
  tst_err_malloc(tmp_str,9);
}

strcpy(tmp_str,name);

if(panels[cpanel].selected)
  { /* Выделено несколько файлов/каталогов */
    /* проверить, есть ли среди отм. файлов каталоги*/
    for(nfile=0, item=panels[cpanel].itembuf, tested=0, incl_dir=0;
	tested<panels[cpanel].selected && nfile<panels[cpanel].nfiles && incl_dir==0;
	item++,nfile++){
	if(item->attrs & MARKED){
	  item_mark=item;
	  tested++;
	  if(filtype(item->mode)==FTYPE_DIR) incl_dir=1;
	}
    }
    if(incl_dir)
      { /* есть каталоги */
	win15.txts[4].active=0;   /* на катлог нельзя сделать HardLink */
	sprintf(str, "Copy %d files and dirs to", panels[cpanel].selected);
      }else{ /* только файлы */
	sprintf(str, "Copy %d files to", panels[cpanel].selected);
      }
    win15.txts[0].txt = str;
    /*win15.txts[0].x=(win15.cols-strlen(str))/2;*/
    switch(inp_menu(inp_lst, &win15, 1, HOR|VERT))
      {
	case 1: /* нажали Enter на имени каталога */
	case 2: /* нажали Enter на <Copy> */
	  if(panels[cpanel].selected==1)
	    { /*безусловно попробовать */
	      copy=1;
	    }else{ /* несколько файлов можно копировать в существ. каталог*/
	      if(stat(tmp_str, &stbuf)==0 &&
		 filtype(stbuf.st_mode)==FTYPE_DIR &&
		 access(tmp_str, W_OK)==0)
		{ /* есть доступный на запись каталог */

		  copy=1;
		}else{ /* что-то не в порядке с каталогом, в который копируем*/
		  copy=0;
		  ask(&win17, 2, HOR);
		}
	    }
	break;
	case 4: /* нажали Enter на <Link> */
	  copy=2;
	break;
	case 5: /* нажали Enter на <SymLink> */
	  copy=3;
	break;
	default: /* ESC и ошибки */
	case 3: /* нажали Enter на <Cancel> */
	  copy=0;
	break;
      }
    /* if(ask(&win15, 0, HOR) == 0) copy=1; */
  }else{ /* копирование одного файла/каталога без отметки */
    item_mark=item= &panels[cpanel].itembuf[panels[cpanel].curfile];
    if(filtype(item->mode)==FTYPE_DIR)
      { /* каталог */
	win15.txts[4].active=0;   /* на катлог нельзя сделать HardLink */
	strcpy(str, "Copy DIRECTORY \"");
      }else{ /* файл */
	strcpy(str, "Copy file \"");
      }
    i=win15.cols-2*win15.txts[0].x-5; /* макс. место для строки */
    strncat(str, panels[cpanel].names+item->nname, i-strlen(str));
    str[i]='\0';
    if(strlen(str)==i){ /* имя поместилось не все*/
      str[i-1]=str[i-2]=str[i-3]='.';
    }
    strcat(str, "\" to");

    win15.txts[0].txt = str;
    /*win15.txts[0].x=(win15.cols-strlen(str))/2;*/
    switch(inp_menu(inp_lst, &win15, 1, HOR|VERT))
      {
	case 1: /* нажали Enter на имени каталога */
	case 2: /* нажали Enter на <Copy> */
	  copy=1;
	break;
	case 4: /* нажали Enter на <Link> */
	  copy=2;
	break;
	case 5: /* нажали Enter на <SymLink> */
	  copy=3;
	break;
	default: /* ESC и ошибки */
	case 3: /* нажали Enter на <Cancel> */
	  copy=0;
	break;
      }

    if(copy){
      /* имитируем отметку */
      /* item= &panels[cpanel].itembuf[panels[cpanel].curfile]; - было выше*/
      item->attrs ^= MARKED;
      panels[cpanel].selected++;
      panels[cpanel].size_sel+=item->size;
    }
  }
if(copy==1 &&
   panels[cpanel].selected==1 &&
   filtype(item_mark->mode)==FTYPE_REG){
   /* копирование одного файла, возможно, с переименованием */
   stbuf.st_mode=0;
   if(stat(tmp_str, &stbuf)!=0 || filtype(stbuf.st_mode)!=FTYPE_DIR){
     copy=4;  /* копировать по cp */
   }
}

if(copy && stat(tmp_str, &stbuf)==0){ /* проверить на overwrite */

  if(filtype(stbuf.st_mode)==FTYPE_DIR)
    { /* копируем в каталог */
      for(ptr=tmp_str; *ptr; ptr++);
      *ptr='/';

      for(nfile=0, item=panels[cpanel].itembuf, tested=0;
	tested<panels[cpanel].selected && nfile<panels[cpanel].nfiles && exists==0;
	item++,nfile++){
	if(item->attrs & MARKED){
	  strcpy(ptr+1, panels[cpanel].names+item->nname);
	  if(access(tmp_str, 0)==0) exists++;
	}
      }
      *ptr='\0';
    }else{ /* копируем в существующий файл*/
      exists++;
    }
}

if(exists){ /* подтверждение на Overwrite */
  if(ask(&win77, 0, HOR) != 0) copy=0;
}

switch(copy)
  {
    case 1: /* просто копирование */
      if(pipe(fd)){
	endwin();
	perror("Can't make pipe");
	exit(-1);
      }
      if(pipe(fd_err)){
	endwin();
	perror("Can't make errors pipe");
	exit(-1);
      }

      sprintf(str, "%d files", panels[cpanel].selected);
      win19.txts[1].x=(win19.cols-strlen(str))/2;
      win19.txts[1].txt=str;
      soob(&win19);

      /* формирование аргументов и т.п. будем вып-ть в отдельном процессе*/
      /* для того, чтобы не запутаться в перераспределении памяти */
      switch(pid=fork())
	{
	  case 0:  /* потомок - будет создавать архив */
	    close(fd[0]);
	    close(fd_err[0]);
	    dup2(fd_err[1],2);
	    close(fd_err[1]);
	    /* освободим память для искл.затыков при формировании списка аргументов*/
	    for(panel=0; panel<NPANELS; panel++){
	      if(panel!=cpanel){
		delwin(panels[panel].win);
		free(panels[panel].full_dir);
		free(panels[panel].itembuf);
		free(panels[panel].names);
	      }
	    }

	    delwin(stdscr);
	    delwin(save_scr);

	    if(!(spis=malloc((panels[cpanel].selected+4)*sizeof(char*)))) exit(-1);

	    spis_p=spis;

	    *spis_p++="tar";
	    *spis_p++="cfp";
	    *spis_p++="-";

	    for(nfile=0, item=panels[cpanel].itembuf, tested=panels[cpanel].selected;
		tested && nfile<panels[cpanel].nfiles;
		item++,nfile++){
		if(item->attrs & MARKED){
		  *spis_p++=panels[cpanel].names+item->nname;
		  tested--;
		}
	    }
	    *spis_p=NULL;
	  close(2);/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
	    dup2(fd[1],1); /* переназначение стандартного вывода*/
	    close(fd[1]);
	    for(i=1;i<NSIG;i++) signal(i, SIG_DFL);
	    execvp(*spis, spis);
	    exit(-1); /* ошибка вызова - будет проверен код*/
	  break;

	  case -1: /* не создается процесс */
	    close(fd_err[0]);
	    close(fd_err[1]);
	    ask(&win3,1,0); /* сообщение об ошибке*/
	  break;

	  default: /* процесс - родитель */
	    switch(pid1=fork())
	      {
		case 0: /* Ыще один потомок - будет читать */
		  close(fd_err[0]);
		  dup2(fd_err[1],2);
		  close(fd_err[1]);

		  if(chdir(tmp_str)) exit(-1);
		  close(fd[1]);
		  dup2(fd[0],0); /* переназначение стандартного ввода*/
		  close(fd[0]);
		  for(i=1;i<NSIG;i++) signal(i, SIG_DFL);
		  execlp("tar", "tar", "xfp", "-", NULL);
		  exit(-1); /* ошибка вызова - будет проверен код*/
		break;

		case -1: /* не создается процесс */
		  close(fd[0]);
		  close(fd[1]);
		  close(fd_err[0]);
		  close(fd_err[1]);
		  ask(&win3,1,0); /* сообщение об ошибке*/
		break;

		default: /* совсем родитель, будет ждать, когда закончатся tar'ы */
		  close(fd[0]);
		  close(fd[1]);
		  close(fd_err[1]);

		  if(read(fd_err[0], str, 1)==1) err++;
		  close(fd_err[0]);

		  i=2; /* количество ожидаемых процессов */
		  do{
		   status=0;
		   pid_ready=wait(&status);
		   if(pid_ready==pid){ /* закончился первый*/
		     if(status) err++;
		     i--;
		   }else if(pid_ready==pid1){ /* закончился второй*/
		     if(status) err++;
		     i--;
		   }
		  }while(i);

		  if(err) ask(&win16,1,0); /* сообщение об ошибке*/

		break;
	      } /* switch(fork..*/
	  break;
	} /* switch(fork..*/
    break;

    case 2: /*============================ Link ============================*/
    case 3: /*========================== SymLink ===========================*/
    case 4: /*====================== Копирование по cp =====================*/

      for(nfile=0, item=panels[cpanel].itembuf;
	  panels[cpanel].selected && nfile<panels[cpanel].nfiles && copy;
	  item++,nfile++){
	  if(item->attrs & MARKED){

	    name=panels[cpanel].names+item->nname;
	    if(strlen(name) >= sizeof(str))
	      { /* полное имя не помещается */
		strcpy(str,"...");
		strncpy(str+3, name, sizeof(str)-3);
		str[sizeof(str)-1]='\0';
	      }else{ /* имя файла помещается целиком*/
		strcpy(str,name);
	      }
	    win20.txts[1].x=(win20.cols-strlen(str))/2;
	    win20.txts[1].txt=str;
	    soob(&win20);

	    switch(pid=fork())
	      {
		case 0:  /* потомок - будет вызывать *copyprog */
		  /* текущий каталог установлен в main() */
		  if((i=open("/dev/null", O_WRONLY))>=0){
		    dup2(i,2); /* переназначение протокола ошибок */
		    close(i);
		  }

		  if(copy==3)
		    { /* Для SymLink нужен ключ и полное имя каталога*/
		      /* освободим память для искл.затыков при формировании*/
		      for(panel=0; panel<NPANELS; panel++){
			if(panel!=cpanel){
			  delwin(panels[panel].win);
			  free(panels[panel].full_dir);
			  free(panels[panel].itembuf);
			  free(panels[panel].names);
			}
		      }

		      delwin(stdscr);
		      delwin(save_scr);

		      if( !(name=malloc(strlen(panels[cpanel].full_dir)+
				     strlen(panels[cpanel].names+item->nname)+
				     2 )) ) exit(-1);

		      strcpy(name,panels[cpanel].full_dir);
		      strcat(name,"/");
		      strcat(name,panels[cpanel].names+item->nname);


		      for(i=1;i<NSIG;i++) signal(i, SIG_DFL);
		      execlp(copyprog[copy], copyprog[copy], "-s",
			     name,
			     tmp_str,
			     NULL);

		    }else{ /* Link или Copy */
		      for(i=1;i<NSIG;i++) signal(i, SIG_DFL);
		      execlp(copyprog[copy], copyprog[copy],
			     panels[cpanel].names+item->nname,
			     tmp_str,
			     NULL);
		    }

		  exit(-1); /* ошибка вызова - будет проверен код*/
		break;

		case -1: /* не создается процесс */
		  ask(&win3,1,0); /* сообщение об ошибке*/
		break;

		default: /* процесс - родитель */
		     while(wait(&wait_stat)!=pid);
		     if(wait_stat)
		       { /* была ошибка */
			 if(say_error){
			   win21.txts[1].x=(win21.cols-strlen(str))/2;
			   win21.txts[1].txt=str;
			   switch(ask(&win21,2,HOR))
			     {
			       default:
			       case 2: /* OK */
			       break;

			       case 3: /* Silently - не спрашивать (в nc этого нет)*/
				 say_error=0;
			       break;

			       case 4: /* Cancel (в nc этого нет)*/
				 copy=0;
			       break;
			     }
			 }
		       }
		     item->attrs ^= MARKED;
		     panels[cpanel].selected--;
		     panels[cpanel].size_sel-=item->size;
		     outpanel=cpanel;
		     refr_panel();

		break;
	      } /* switch */
	  } /* if(отмечен) */
      }   /* for по файлам */
    break;

  } /* switch(copy) */
delsoob();

/* Восстановление нормального экрана */
for(outpanel=0;outpanel<NPANELS;outpanel++){
    if(copy)
      { /* что-то копировалось */
	nfile=panels[outpanel].curfile;
	nfirst=panels[outpanel].firstfile;
	if(chdir(panels[outpanel].full_dir)) beep();
	read_to_panel();
	if(nfile<panels[outpanel].nfiles) {
	  panels[outpanel].firstfile=nfirst;
	  panels[outpanel].curfile=nfile;
	  refr_panel();
	}
      }else{
#ifdef FREEBSD
	if(panels[outpanel].on>0) refr_panel();
#else
	if(panels[outpanel].on>0) touchwin(panels[outpanel].win);
#endif
      }
    if(panels[outpanel].on>0) wrefresh(panels[outpanel].win);
}

}
