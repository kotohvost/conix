/*              Функции асинхронной работы с клавиатурой        */
/*****************************************************************************
 *      kbstart() - Создание процесса-читателя клавиатуры
 *      kbhit()   - Проверка наличия введенных символов.
 *                  Возвращает их количество
 *      kbget()   - ввод кодов с клавиатуры и определение их типов с
 *                  расшифровкой. переделано из getkey_()
 *      kbstop()  - Остановка процесса-читателя клавиатуры
*****************************************************************************/

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <signal.h>
#include <stdio.h>
#include <ctype.h>
#include "keys.h"

static  fd[2];  /* для создания программного канала */
static pid_t pid; /* номер процесса-читателя клавиатуры */

/****************************************************************************/
		kbstart()
/*      Создание процесса-читателя клавиатуры

*****************************************************************************/
{
	char    ch;
static  char    nul=0;

if(pid){
  fprintf(stderr, "Programmer error (double kbstart())\n");
  exit(-1);
}

if(pipe(fd)!=0){
    perror("kbstart:Can't create pipe");
    exit(-1);
}

switch(pid=fork())
  {
    case 0: /* порожденный процесс */
      signal(SIGINT, SIG_DFL); /* curses выставляет свою обработку (endwin() или что-то подобное)*/
      close(fd[0]);
      while(1){
	if(read(0, &ch, 1)==1)
	  {
	    write(fd[1], &ch, 1);
	  }else{
	    close(fd[1]);
	    exit(-1);
	  }
      }
    break;
    case -1: /* не создается процесс */
      perror("kbstart:Can't create process");
      exit(-1);
    break;
    default: /* читатель создан */
      close(fd[1]);
    break;
  }
}


/****************************************************************************/
		size_t kbhit()
/*      Проверка наличия введенных символов
	Возвращает их количество
*****************************************************************************/
{
	struct stat stbuf;
/*==========================================================================*/
if(!pid) kbstart();
stbuf.st_size=0;
if(fstat(fd[0], &stbuf)!=0){
  perror("kbhit:Can't fstat pipe");
  exit(-1);
}
return(stbuf.st_size);
}

/****************************************************************************/
		int kbget()
/*      ввод кодов с клавиатуры и определение их типов с расшифровкой
 *      переделано из getkey_()
*****************************************************************************/
{
extern struct   cmdkey  stringcom_[];   /* */
       unsigned char    str_[256];      /*строка-ответ п-ля*/
auto            int     priznpovt;      /*призн. продолж. поиска*/
auto   unsigned char    *simb;          /*указатель на введенный символ*/
auto            int     cmd;            /*команда - рез-т getkey*/
auto            int     povtlstr;       /*призн.повтора поиска по строкам*/
	 unsigned char    *ukch;        /*ук-ль на текущ. сравн. символ*/
	 unsigned char    *ukch1;       /*ук-ль на текущ. сравн. символ*/
	 struct cmdkey  *uk;            /*ук-ль на текущий эл-т stringcom*/
/*==========================================================================*/
str_[0]='\0'; /* Not in INDIS-2 !!!*/
priznpovt=1;
for(simb=str_;priznpovt;simb++) {
  if(*simb=='\0') {
    read(fd[0],simb,1);

    if(!*simb) return(ERROR_KEY);

/*  *simb=getch(); */
    *(simb+1)='\0';
  }
  /*м.б. последовательность из stringcom; сюда же относятся CR и т.п.*/
  povtlstr=1;
  for(uk=stringcom_;uk->command && povtlstr;uk++){/*поиск по шаблонам команд*/
    if(uk->string)
      { /*послед-ть из stringcom*/
	for(ukch1=str_,ukch=(uk->string);
	    (*ukch==*ukch1) && *ukch;
	    ukch++,ukch1++);
	if(*ukch1=='\0') { /*совпадение или мало символов*/
	    if(*ukch=='\0')
	      { /*полное совпадение*/
		cmd=uk->command;
		priznpovt=povtlstr=0;
	      }else{ /*частичное совпадение*/
		povtlstr=0;
	    } /* (*ukch=='\0') */
	}  /* *ukch1=='\0'*/
    } /*(uk->string!=0) */
  } /*по командам*/
  if(povtlstr) { /*несовпадение*/
      if(isprint(str_[0]) && str_[1]=='\0')
	{ /*одиночный символ (isprint должен воспринимать кириллицу)*/
	  cmd=PECH_SIMB|str_[0];
	}else{
	  cmd=ERROR_KEY|str_[0];
      }
      priznpovt=0;
  }
}
return(cmd);
}

/****************************************************************************/
		kbstop()
/*      Остановка процесса-читателя клавиатуры
*****************************************************************************/
{
/*==========================================================================*/
kill(pid, SIGINT);
while(wait(NULL) != pid);       /* для того, чтобы не было зомби */
pid=0;
}
