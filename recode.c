#include "recode.h"
#ifdef SOLARIS1
/****************************************************************************/
			int     recode(ch, src, targ)
/*              Заглушка для Solaris 1
*****************************************************************************/
	int     ch;             /* перекодируемый символ */
	int     src;            /* исходная кодировка */
	int     targ;           /* результирующая кодировка */
{
return(ch);
}
#else
/****************************************************************************/
			int     recode(ch, src, targ)
/*              Перекодировка символа ch из кода src в код targ
*               !!! При перекодировании самого файла ОСТАВИТЬ ТАБЛИЦУ !!!
*****************************************************************************/
	int     ch;             /* перекодируемый символ */
	int     src;            /* исходная кодировка */
	int     targ;           /* результирующая кодировка */
{
static  int     first=1;        /* признак первого вызова (для построения таблицы)*/
static  unsigned char    *tbl_ptr[NUMCODES][NUMCODES]; /* указатели на таблицы переводировок*/
	int     srct;
	int     targt;
	int     i;
       unsigned char    *new_t; /* новая таблица */
       unsigned char    *src_t; /* базовая таблица "исходного" кода*/
       unsigned char    *targ_t;/* базовая таблица "результирующего" кода*/
static unsigned char    tables[NUMCODES*(NUMCODES-1)+1][129]=
		  /* перекодировки из базовой в другие */
		{
/* Alt  */       "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№¤■?",
/* ISO  */       "░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀????????????????????????????????????????????????рстуфхцчшщъыьэюябё??????????Ё???",
/* KOI8 */       "стўчфхЎ·щъыьэюяЁЄєЇїцшу■√¤ ∙°№рё┴┬╫╟─┼╓┌╔╩╦╠═╬╧╨РСТБЗ▓┤нм╡боизжЕВИЙЖАКп░ел╕╗▒а╛╢╖╣║двйк╜╝ГДНМОПЛ╥╙╘╒╞╚├▐█▌▀┘╪▄└╤│гЩШУЫЯХЬЮ┐ЦЧЭФ?",
/* MS-WIN*/      "└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюя????????????????????????????????????????????????ЁёЄєЇїЎў°∙·√№¤■ и╕??????????╣???",

		  /* остальные таблицы перекодировки будут здесь */
		 "????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????",
		 "????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????",
		 "????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????",
		 "????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????",

		 "????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????",
		 "????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????",
		 "????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????",
		 "????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????",

		 "????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????",
		};
/*==========================================================================*/
if(src==targ) return(ch); /* нечего перекодировать */
if ( ch < 0 ) ch &= 0377;
if(first){
  /* прописать таблицы перекодировки базовой(альтернативной) в другие */
  for(targt=0;targt<NUMCODES;targt++) tbl_ptr[0][targt]=tables[targt];

  /* из других в базовую и друг в друга */
  first=NUMCODES; /* поиспользуем как временную переменную */
  for(srct=1; srct<NUMCODES; srct++){ /* ...=1: базовая -> в другие - прописано */
    for(targt=0; targt<NUMCODES; targt++){
      if(srct==targt)
	{ /* без перекодировки */
	  tbl_ptr[srct][targt]= tables[0];
	}else{
	  new_t=tbl_ptr[srct][targt]= tables[first];
	  src_t=tables[srct];
	  targ_t=tables[targt];
	  for(i=0; src_t[i]; i++){
	    if(src_t[i]>=BASE) new_t[src_t[i]-BASE] = targ_t[i];
	  }
	  first++; /* следующий свободный элемент tables[] */
	}
    }
  }
  first=0;
}

return((ch>=BASE) ? tbl_ptr[src][targ][ch-BASE] : ch);
}
#endif
